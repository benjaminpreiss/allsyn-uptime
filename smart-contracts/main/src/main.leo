import credits.aleo;
import token_registry.aleo;
// The 'aleo_checker_nft' program.
program allsyn.aleo {
    // the public balance of each token for each owner is tracked by token_registry for me.
    // In allsyn, we register a new token for every valuation. 

    // the allsyn token_id from the token_registry
    const ALLSYN_TOKEN_ID: field = 01232field;

    // the smart contract admin
    const ALLSYN_ADMIN: address = aleo1007a9le5mn6pj08fdssmcvw0y9nc6x63erpll6aax3yech3qkcysdz39f2;

    // receipt valuations (in allsyn tokens / # check cycles) when they were minted.
    mapping receipt_valuations: field => DecimalValue;

    // check cycle valuation history (in allsyn tokens / # check cycles) when they were minted.
    // We want to keep this valuation dynamic to make stablize the cost of one check expressed in dollars.
    // timestamp measured as epoch in seconds => DecimalValue.
    // we also store the latest valuation at epoch 0.
    mapping check_cycle_valuation: u64 => DecimalValue;

    // token data. maps token_id from token_registry -> data
    mapping data: field => Data;

    // receipt balances
    // nft commits (which is hash of data and edition) => Balance
    mapping balances: field => u64;

    // The token valuation represented as an unsigned int (significand) x exponent (to base 10).
    // So e.g. (104, -1) would be 10.4
    struct DecimalValue {
        // max value 18,446,744,073,709,551,615 (u64)
        significand: u64,
        // scaling factor base 10, signed integer, value range [0, 255].
        // This exponent is only used to represent decimals! so 1 for 10^-1, 2 for 10^-2 etc.
        neg_exponent: u8,
    }

    struct MetaData {
        // irys tx id has 32 bytes of raw data - fits into field.
        irysTxId: field,
    }

    struct Data {
        metadata: MetaData, // URI of off-chain metadata JSON
        // Optional fields like name, image, attributes can be added here
    }
    // Receipt that is returned for payment with allsyn_tokens
    record Receipt {
        private owner: address,
        private edition: scalar,
        public data: Data,
        // transacted amount of check cycles, cannot be < 0 and is integer.
        public check_cycles: u32,
        // At what valuation was the receipt generated?
        public valuation: DecimalValue,
    }
    
    inline commit_nft(
        data: Data,
        edition: scalar
    ) -> field {
        let data_hash: field = BHP256::hash_to_field(data);
        let commitment: field = BHP256::commit_to_field(data_hash, edition);
        return commitment;
    }

    // Initialize the program after deployment.
    async transition init() -> Future {
        return finalize_init();
    }

    async function finalize_init() {
        // Make sure caller is ALLSYN_ADMIN
        assert(self.caller == ALLSYN_ADMIN);
        // Set first check_cycle_valuation, if not already done
        if !Mapping::contains(check_cycle_valuation, 0u64) {
            let base_check_cycle_valuation: DecimalValue = DecimalValue {
                // daily checks = 100 (checker nodes) x 60 (hourly checks) x 24 = 144.000 checks
                // monthly checks (at 30 days) = 4.320.000 checks
                // check cycle value = 3$ / ( 0.1271 * 10^-6 ) ($ / allsyn token) / 4.320.000 check cycles = 5.463764315 allsyn token / check cycle
                significand: 5463764315u64,
                neg_exponent: 9u8
            }
            Mapping::set(check_cycle_valuation, 0u64, base_check_cycle_valuation);
        }
    }

    inline safe_pow10(exp: u8) -> u64 {
        assert(exp <= 19u8); // prevent overflow
        return 10u64 ** exp;
    }


    // buy check cycles <-> mint private receipt
    // pay with allsyn token
    async transition mint_private_receipt (
        private input: token_registry.aleo/Token,
        // recipient of receipts
        public to: address,
        // amount of check cycles
        public check_cycles: u64,
        // origin of receipts
        public holder: address,
        public data: Data,
        private edition: scalar,
    ) -> (token_registry.aleo/Token, Receipt, Future) {
        // the commit generated by the edition needs to be new
        let receipt_nft_commit: field = commit_nft(data, edition);
        // commit has to be new to balances, as only new receipts can be minted.
        // Otherwise edition needs to be picked again.
        assert_eq(Mapping::contains(balances, receipt_nft_commit), false);

        // token with which the user pays needs to be allsyn token
        assert_eq(input.token_id, ALLSYN_TOKEN_ID);
        // check_cycle_valuation needs to exist
        assert_eq(Mapping::contains(check_cycle_valuation, 0u64), true);

        // most recent valuation always at index 0 of valuation mapping
        let current_check_cycle_valuation: DecimalValue = Mapping::get(check_cycle_valuation, 0u64);

        // How much does the user need to pay in allsyn tokens? check_cycle_valuation x check_cycles
        let allsyn_token_amount_numerator: u64 = check_cycles * current_check_cycle_valuation.significand;
        let allsyn_token_amount_denominator: u64 = safe_pow10(current_check_cycle_valuation.exponent);
        // Ceiling division, i.e. round allsyn_token_amount up. Wastes credits, only if you buy small amounts of check cycles
        let allsyn_token_amount: u64 = (allsyn_token_amount_numerator + allsyn_token_amount_denominator - 1u64) / allsyn_token_amount_denominator;

        // transfer allsyn token
        let allsyn_token_change: token_registry.aleo/Token = token_registry.aleo/transfer_private_to_public(holder, allsyn_token_amount, input);

        // create receipt
        let receipt_change: Receipt = Receipt {
            owner: to,
            edition: edition,
            data: data,
            check_cycles: check_cycles
            valuation: current_check_cycle_valuation
        };
        let mint_receipt_future: Future = finalize_mint_receipt(receipt_nft_commit, check_cycles);
        return (allsyn_token_change, receipt_change, mint_receipt_future);
    }

    async function finalize_mint_receipt(
        nft_commit: field,
        balance: u64,
    ) {
        // update balances
        Mapping::set(balances, nft_commit, balance);
    }
}
